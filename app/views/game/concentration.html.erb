<div x-data="concentration">
  <h1 x-text="playerName"></h1>
  <div class="flex justify-center">
    <div class="grid grid-cols-4">
      <template x-for="(tile, index) in gameData.tiles">
        <div
          class="cursor-pointer h-16 w-16 border-yellow-300 border-2"
          @click="toggle(index); gameover()"
        >
          <img
            x-show="gameData.open[index]"
            :src="`https://robohash.org/${gameData.tiles[index]}.png?bgset=bg1&set=set4`"
            class="cursor-pointer h-16 w-16"
          />
        </div>
      </template>
    </div>
    <h1 x-text="gameData.turn"></h1>
  </div>
</div>
<script>
  const socket = io("http://localhost:3001", {
    transports: ["websocket"],
  });
  document.addEventListener("alpine:init", () => {
    Alpine.data("concentration", () => ({
      whenIEnteredTheGame: null,
      playerName: "Player 1",
      playedBy: "",
      gameData: {
        open: {},
        tiles: [],
        firstOpenTile: null,
        secondOpenTile: null,
        rounds: 0,
        no_of_clicks: 0,
        turn: "Player 1",
      },
      booleanVariable: false,
      init() {
        this.whenIEnteredTheGame = new Date();
        this.create8uniquepairs();
        socket.on("gameDataUpdate", (data) => {
          this.gameData = data.gameData;
          this.playedBy = data.playerName;
        });

        socket.on(
          "someOtherPlayerEntered",
          (timeTheOtherPersonEnteredTheGame) => {
            //   if (timeTheOtherPersonEnteredTheGame == this.whenIEnteredTheGame) {
            //     return;
            //   }
            //   if (timeTheOtherPersonEnteredTheGame > this.whenIEnteredTheGame) {
            //     this.playerName = "Player 1";
            //   } else {
            //     this.playerName = "Player 2";
            //   }
            if (this.booleanVariable == false) {
              this.playerName = "Player 1";
              this.booleanVariable = true;
            } else {
              this.playerName = "Player 2";
            }
          }
        );
        socket.emit("someOtherPlayerEntered", this.whenIEnteredTheGame);
      },
      gameover() {
        let solvedTileCount = 0;
        for (key in Object.keys(this.gameData.open)) {
          if (this.gameData.open[key] == true) {
            solvedTileCount += 1;
          }
        }
        if (solvedTileCount == 16) {
          alert(`You have won and used ${this.gameData.rounds} rounds!`);
        }
      },
      toggle(index) {
        console.log(this.gameData.turn);
        console.log(this.playerName);
        console.log(this.gameData);
        if (this.gameData.no_of_clicks > 0 && this.gameData.open[index]) {
          return;
        }
        if (this.gameData.turn != this.playerName) {
          return;
        } else {
          // turn = another player
        }
        this.gameData.no_of_clicks += 1;
        if (this.gameData.no_of_clicks == 3) {
          // third click
          if (
            this.gameData.tiles[this.gameData.firstOpenTile] !=
            this.gameData.tiles[this.gameData.secondOpenTile]
          ) {
            this.gameData.open[this.gameData.firstOpenTile] = false;
            this.gameData.open[this.gameData.secondOpenTile] = false;
            if (this.gameData.turn == "Player 1") {
              this.gameData.turn = "Player 2";
            } else {
              this.gameData.turn = "Player 1";
            }
          }
          this.gameData.firstOpenTile = null;
          this.gameData.secondOpenTile = null;
          this.gameData.no_of_clicks = 0;
        } else if (this.gameData.no_of_clicks == 2) {
          // second click
          this.gameData.rounds += 1;
          this.gameData.secondOpenTile = index;
          this.gameData.open[index] = true;
        } else if (this.gameData.no_of_clicks == 1) {
          // first click
          this.gameData.firstOpenTile = index;
          this.gameData.open[index] = true;
        }
        socket.emit("gameDataUpdate", {
          gameData: this.gameData,
          playerName: this.playerName,
        });
      },
      create8uniquepairs() {
        for (let i = 0; i < 8; i++) {
          let png_number = Math.random(30000);
          this.gameData.tiles.push(png_number);
          this.gameData.tiles.push(png_number);
        }
        this.shuffle(this.gameData.tiles);
      },
      shuffle(array) {
        let currentIndex = array.length,
          randomIndex;
        while (currentIndex != 0) {
          randomIndex = Math.floor(Math.random() * currentIndex);
          currentIndex--;
          [array[currentIndex], array[randomIndex]] = [
            array[randomIndex],
            array[currentIndex],
          ];
        }
        return array;
      },
    }));
  });
</script>
